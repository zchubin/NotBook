<CENTER style="font-size: 24px;font-weight: 700;">大数据与云计算</CENTER>

[目录](./00-目录.md)

## HBase
### 4.1HBase简介
#### 1. Big Tabel 诞生:

* 主要就是满足互联网搜索引擎的基本需求
* 用于网页搜索
* 用于谷歌非常多的项目里面，包括搜索、地图、财经、打印
* 还有一些社交网站 视频共享网站 博客网站等

#### 2. HBase 特点(可用于存储非结构化和板结构化的松散数据):

* **高可靠**
* **高性能**
* **面向列**
* **可伸缩**
    - 底层分布式文件系统 : 存储完全非结构化的数据
    - HBase              : 通过水平扩展,允许几千台服务器去存储海量文件

#### 3. HBase和Big Tabel的底层技术对应关系

|              | Big Tabel | HBase            |
| ---          | ---       | ---              |
| 文件存储系统 | GFS       | HDFS             |
| 海量数据处理 | MapReduce | Hadoop MapReduce |
| 协同管理服务 | Chubby    | ZooKeeper        |

> ### 为什么还要去设计 HBase 这么一个数据库产品?
>> * 虽然已经有了 HDFS 和 MapReduce, 但是 Hadoop 主要解决大规模数据离线批量处理 Hadoop 是没有办法满足大数据实时处理需求的,随着这些年数据的大规模爆炸式增长,传统关系型数据库的扩展能力非常有限
>> * 这样操作有两个缺陷,一个是不便利,另一个是效率非常低
> ### HBase 和传统的关系型数据库有什么联系和区别?
>> 1. 数据类型方面,传统的关系型数据库用的是非常经典的关系型数据模型
>> 2. 数据操作方面,在关系型数据库当中定了非常多的数据操作
>> 3. 存储模式方面,关系型数据是基于行模式存储,而对于 HBase 来讲是基于列存储
>> 4. 数据索引方面,关系数据库可以直接针对各个不同的列,构建非常复杂的索引
>>
>> | 关系型数据库 | 主索引+多二级索引      |
>> | :---:        | :---:                  |
>> | HBase        | 只支持对行键的简单索引 |
>>
>> 5. 数据维护方面,在关系数据库当中做一些更新操作的时候,实际上里面的值会被新的值覆盖掉
>> 6. 可伸缩性方面,关系数据库是很难实现水平扩展的，最多可以实现纵向扩展

#### 4. HBase访问接口:

4.4.1. 提供了一个原生 Java API:

* shell
* Thrift Gateway 方式
* REST Gateway

4.4.2. 提供 SQL 类型接口:

* Pig (大规模数据查询平台,提供类似 SQL 查询语句)
* Hive 数据仓库产品

### 4.2HBase数据模型

> ### HBase是一个稀疏的多维度的排序的映射表
> * 行键
> * 列族 : 支持动态扩展，保留旧的版本
> * 列限定符
> * 单元格 : 具体存储数据的地方
> * 时间戳 : 新的版本会通过时间戳来进行区分
>> 1. HBase 每一个值都是未经解释的字符串也就是 Bytes 数组
>> 2. 一个行可以有一个行键和任意多个列
>> 3. 列族是 HBase 当中一个非常核心的概念

#### 数据坐标的概念

1. 传统的关系数据库的定位

    * 只通过一个行一个列这两个维度就可确定一个唯一数据(Excel 表格就类似于关系数据库)

2. HBase 对数据的定位

    * 采用思维坐标来定位
    * 必须确定**行键**、**列族**、**列限定符**、**时间戳**
	* 键值数据

3. 面向行的存储有什么优势和缺点

	* 优点 ：
		- 对于传统的事务型操作，需要每次插入一条数据的时候，会把这条数据记录的各项信息都存入数据库
		- 在OLTP系统中，每一次都生成一个完整的数据记录
		
	* 缺点 :
		- 对于行式存储来讲，为了取出一列数据,必须先扫描整个数据库
		- 分析年龄分布特征，都是针对一个列去分析

#### HBase数据库产品
	
* 列式存储 : 企业以分析型数据库为主 --- 可以带来和高的数据压缩率
* 行式存储 : 事务型数据库位置 --- 不可能达到很高的数据压缩率

### 4.3 HBase 的实现原理


1. HBase 的功能组件
	
	* 库函数 --- 一般用于连接每个客户端
	* Master 服务器 --- 充当管家的作用
	* Region 服务器 --- 负责存储不同的 Region

	> #### Master 服务器
	> 1. 分区信息进行维护和管理
	> 2. 维护了一个 Region 服务器列表
	> 3. 整个集群当中有哪些 Region 服务器在工作
	> 4. 负责对 Region 进行分配
	> 5. 负载平衡
	> #### Region 服务器
	> 1. Region 服务器维护和管理 Region,并处理客户端请求
	> 2. 客户端并不依赖于 Master 去获取位置信息
	> 3. 一个 HBase 表被划分成多个 Region(按照行键字典排序),一个 Region 会分裂成多个新的 Region
	>> * Region 的大小为 100MB 到 200MB
	>> * 一个 Region 的大小最佳配置为 1GB 到 2GB
	>> * Region 的实际大小，取决于单台服务器的有效处理能力
	>> * 对于同一个 Region 它是绝对不会被拆分到到不同 Region 服务器上
	>> * 每一个 Region 服务器，大概可以存储 10 到 1000 个 Region
	
2. 两大核心概念表和 Region

	> #### Region 到底被存储到哪去了?
	> ##### HBase 设计了三层结构来实现 Region 的寻址和定位
	>> - 首先要构建一个元数据表（假设这个元数据表只有两列，第一列是 Region 的 id,第二列是 Region 服务器 id）
	>> - HBase 最是开始构建时有一个映射表，这个映射表被称为`.META`表
	>> - `.MATE`表是用于存储元数据的
	>> ![HBase-Region](./img/HBase-Region.svg)
	>> 
	>> | 层次 | 名称 | 作用|
	>> | :---: | :---: | :---: |
	>> | 第一层 | Zookeeper 文件| 记录了 -ROOT- 表的位置信息 |
	>> | 第二层 | -ROOT- 表 | 记录了`.META`表的 Region 位置信息，-ROOT-表只能有一个 Region。通过-ROOT-表，就可以访问`.MATE`表中的数据 |
	>> | 第三层 | `.MATE`表 | 记录了用户数据表的 Region 位置信息，`.MATE`表可以有多个Region。保留了HBase中所有用户数据表的Region位置信息 |
	>> 
	>> ##### Region 定位
	>> - 为了加快访问速度，`.META`表的全部 Region 都会保存在内存中
	>> - 假设`.META`表的每行(一个映射条目)在内存中大约占用1KB,并且每个Region限制为128MB，那么，上面的三层结构可以保存的用户数据表的Region数目的计算方法是：
	>> - (-ROOT-表能够寻址的`.META`表的Region个数)*(每个`.META`表的Region可以寻址的用户数据表的Region个数)
	>>> (128M/1k)*(128M/1K)=2^34
	>> **为了加速寻址，客户端会缓存位置信息，同时，需要解决缓存失效问题**
	
3. 怎么实现 Region 定位
