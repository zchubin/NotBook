# 第一章 深入理解Linux操作系统
> 了解操作系统管理系统资源的方法，有助于我们了解在任何应用程序场景中所需要的子系统。

## Linux 进程管理
> 有效的**进程**管理能够让一个应用程序稳定有效的运行。

### 1. 什么是进程
> 进程是在处理器上执行的一个实例，进程可以使用任意资源以便Linux内核可以处理完成它的任务。

* 在Linux操作系统上运行的所有进程都是通过**task_struct**结构来管理的，也被称为“进程描述符”
  - 进程描述符=进程标识+进程属性+构建进程的资源+ ...
### 2. 进程的生命周期
> 每个进程都有自己的生命周期。
> 进程是处理器调度的最小单位。

* 创建 、执行、终止、删除等
* 典型的进程生命周期
  1. 当一个进程创建一个新的进程的时候，创建进程(父进程)发出一个`fork()`系统调用
  2. 父进程得到一个新创建的进程(子进程)的`描述符`，并设置一个新的`进程ID`
  3. `它复制父进程的进程描述的值，给子进程`
  4. 此时父进程的整个地址空间不能被复制，`两个进程共享相同的地址空间`
  5. `exec()`系统调用将新的程序复制到子进程的地址空间，`两个进程共享相同的地址空间`，所以新程序写数据是会导致页面错误。对此，内核会给子进程分配新的物理页
      - 这种延迟的操作被称为`Copy Write`。通常子进程执行它自己的程序，而不是执行与父进程相同的操作。此操作可以`避免不必要的系统开销`，因此复制整个地址空间是非常慢和低效的操作，会占用系统大量的时间和资源
  6. 当程序执行完成的时候，通过一个`exit()`系统调用终止子进程
  7. `exit()系统调用释放进程的大部分数据结构并发一个终止信号通知父进程。此时的进程被称为僵尸进程(zombie process)`
  8. 子进程不会完全被移除，知道父进程通过`wait()`系统调用得知子进程以终止
  9. 只要子进程的终止通知发送到父进程，父进程就会`移除所有子进程的数据结构，并释放所有进程描述符`
### 3. 线程
> 线程是在进程产生的的一个执行的单元，其在同一个进程中与其他线程并行运行,共享相同的资源。
>> 因为共享资源，所以他们中的每个线程不能同时改变它们共享的资源。
> 线程是资源分配的最小单位。

* 互斥、锁、序列化
* 线程实现：
  - **LinuxThreads**(2.0开始)：有一些不符合POSIX标准的实现，未来企业级Linux发行版不
  支持LinuxThreads。
  - **NPTL**(Native POSIX Thread Library)：RedHat开发，更加符合POSIX标准，增强的
  2.6内核的性能。有更好的性能和可扩展性。
  - **NGPT**(Next Generation POSIX Thread)：IBM开发，目前处在维护状态，并没有进一步
  发展的计划，使用`LD_ASUME_KERNEL`环境变量，可以选择应用程序要使用的形成库。

### 4. 进程的优先级和nice等级
> 优先级用来确定CPU处理进程的顺序，并可以确定静态(实时)优先级和动态(非实时)优先级。
>> 对于动态优(非实时)先级，内核需要使用一个基于进程行为和特征的算法做上下`+/-5`的
>> 动态调整。
> 一个进程可以间接地通过使用进程的nice级别来改变静态优先级。
> 一个具有较高静态优先级的进程会具有更长的时间片。

* Root 可以改变nice级别，负数nice将得到一个较高的优先级。

### 5. 上下文切换(context switching)
> 执行的进程被加载到寄存器的数据集被称为上下文(context)。

* 在切换的过程中：
* 先存储运行进程的上下文，
* 然后将下一个要运行的进程上下文恢复到寄存器。
  - 进程描述符和内核模式堆栈用于存储上下文。
  - 上下文切换每次要刷新寄存器和高速缓存(cache)以便释放空间给新的进程。这会导致
  性能问题。

### 6. 中断处理
> 中断处理是优先级最高的任务之一。

* 当一个中断信号到达内的时候，内核必须从当前执行的进程切换到一个新的进程，以处理
中断。
  - 这意味着中断会导致上下文切换，也暗示着大量的中断会导致性能下降。
* 硬中断和软中断：
  - 硬中断：由硬件设备产生，需要快速响应
  - 软中断：被用来处理可以推迟的任务
* 在多处理器环境中，中断是由每个处理器处理的，**将中断绑定到单个处理器上可以提高系统的性能**。

### 7. 进程状态
> 每个进程都有自己的状态，在进程执行期间进程状态会变化。

* **TASK_RUNNING**(运行态)：进程在CPU上运行，或在队列(运行队列)中等待。
* **TASK_STOPPED**(停止态)：进程由于某些信号被暂停。
* **TASK_INTERRUPTIBLE**(可中断睡眠态)：进程暂停，并等待某个条件得到满足，此状态的到停止信号，进程将被中断。
* **TASK_UNINTERRUPTIBLE**(不可中断睡眠态)：状态下会给进程发送一个不执行任何操作的信号。
* **TASK_ZOMBIE**(僵尸态)：一个进程在等待通知它的父进程释放所有的数据结构。
  - 当一个进程接受到一个终止信号时，在它结束之前一般需要一些时间结束所有任务，通常很短时间内，这个进程是一个僵尸进程。
  - 有时候，一个僵尸进程不能终止自己，在这种状态下显示为Z(僵尸)状态。
  - 使用`kill`命令是不能杀死这样一个进程的，因为它已经被认定为死亡。
  - 如果你无法摆脱一个僵尸进程，你可杀死父进程，这样僵尸就会消失。
  - `init`进程是一个非常重要的进程，如果僵尸进程的父进程是init，那么需要重新启动系统来摆脱僵尸进程。

## Linux 内存体系结构
## Linux 文件系统
## Linux 磁盘I/O子系统
## Linux 网络子系统
## Linux 性能度量衡
